import { TemplatePreviews, TemplateEngineOptions } from "../../engines/index.js";
import { MappedRecord, EmailString } from "../../util/index.js";

/**
 * How we pass around the result of a merge on one record.
 *
 * This is the result of merging a single record with a template.
 */
export interface MergeResult {
    /** The record used to create this result */
    record: MappedRecord;
    /** The previews generated by the engine */
    previews: TemplatePreviews;
    /** Metadata about the engine used, so we can get it back later */
    engineInfo: {
        /** Engine used */
        name: string;
        /** Options given to the engine */
        options: TemplateEngineOptions;
    };
    /** Paths to attachments to include in the final email, likely relative to CWD */
    attachmentPaths: string[];
    /** Metadata for emailing */
    email: {
        to: EmailString[];
        cc: EmailString[];
        bcc: EmailString[];
        subject: string;
    };
}

/**
 * Object passed to the storage backend to store the result of a merge on one record.
 *
 * The point of this is to provide backends with a property to store their own data about the merge result,
 * specifically {@link MergeResultWithMetadata.storageBackendMetadata},
 * which will be passed back to them by us after processing the result (after e.g. a rerender)
 *
 * @template Metadata You're free to define your own metadata type for your storage backend, and pass it here to set the type of {@link MergeResultWithMetadata.storageBackendMetadata}
 */
export type MergeResultWithMetadata<Metadata = unknown> = MergeResult & {
    storageBackendMetadata: Metadata;
};

/**
 * Modes for a post-send action
 */
export enum PostSendActionMode {
    /** The email was sent */
    SMTP_SEND = "sent",
    /** The email was uploaded to drafts intead */
    DRAFTS_UPLOAD = "drafts",
}

/**
 * Interface for a storage backend, which is responsible for loading and storing merge results.
 *
 * This is the interface you need to implement to store merge results in your own way.
 *
 * @template Metadata You're free to define your own metadata type for your storage backend, and pass it here to set the type of {@link MergeResultWithMetadata.storageBackendMetadata}
 */
export interface StorageBackend<Metadata = unknown> {
    /** Return an async iterator of merge results, loaded as you want */
    loadMergeResults(): AsyncGenerator<MergeResultWithMetadata<Metadata>>;
    /**
     * Store the original merge results back to the storage - called after it is first generated
     * @param results Results to save
     * @param rawData Data used - headers and the _mapped_ record used to generate the results - in case you find it useful
     */
    storeOriginalMergeResults(
        results: MergeResult[],
        rawData: { headers: Set<string>; records: MappedRecord[] },
    ): PromiseLike<void>;
    /**
     * Store updated merge results back to the storage.
     * Note that the metadata you provided in {@link MergeResultWithMetadata.storageBackendMetadata} will be passed back to you on that property
     *
     * Treat this as a complete update option (think PUT vs PATCH)
     */
    storeUpdatedMergeResults(results: MergeResultWithMetadata<Metadata>[]): PromiseLike<void>;
    /**
     * Called after a merge result has been sent or uploaded to drafts, so that you can do any post processing.
     *
     * Note that you must handle both cases of sending and uploading to drafts, as the mode is passed to you.
     *
     * E.g. Move file around, mark as sent in database
     */
    postSendAction?(
        resultSent: MergeResultWithMetadata<Metadata>,
        mode: PostSendActionMode,
    ): PromiseLike<void>;
}
